/*
The nPose scripts are licensed under the GPLv2 (http://www.gnu.org/licenses/gpl-2.0.txt), with the following addendum:

The nPose scripts are free to be copied, modified, and redistributed, subject to the following conditions:
    - If you distribute the nPose scripts, you must leave them full perms.
    - If you modify the nPose scripts and distribute the modifications, you must also make your modifications full perms.

"Full perms" means having the modify, copy, and transfer permissions enabled in Second Life and/or other virtual world platforms derived from Second Life (such as OpenSim).  If the platform should allow more fine-grained permissions, then "full perms" will mean the most permissive possible set of permissions allowed by the platform.
*/

string DEFAULT_PREFIX="SET";

integer DIALOG=-900;
integer DIALOG_RESPONSE=-901;

integer DOPOSE=200;
integer DO=220;
integer NC_READER_REQUEST=224;
integer NC_READER_RESPONSE=225;
integer DOMENU=-800;
integer UPDATE_UDP=-808; //sends a 3-strided list udpName|udpType|udpValue
integer UPDATE_MACRO=-809; //sends a 3-strided list macroName|macroType|macroValue
integer PLUGIN_MENU_REGISTER=-810;
integer MENU_SHOW=-815;
integer PREPARE_MENU_STEP1=-820;
integer PREPARE_MENU_STEP2=-821;
integer PREPARE_MENU_STEP3=-822;
integer PLUGIN_ACTION=-830;
integer PLUGIN_ACTION_DONE=-831;
integer PLUGIN_MENU=-832;
integer PLUGIN_MENU_DONE=-833;

integer MEMORY_USAGE=34334;
integer SEAT_INIT=250;
integer SEAT_UPDATE=251;
integer OPTIONS=-240;


//dialog buttons
string BACKBTN="^";

// userDefinedPermissions
string PERMISSION_GROUP="group";
string PERMISSION_OWNER="owner";
string PERMISSION_SEATED="seated";
string PERMISSION_OCCUPIED="occupied";
string PERMISSION_OWNSEAT="ownseat";
string UDP_TYPE_LIST="l";
string UDP_TYPE_BOOL="b";
string MACRO_TYPE="m";

//NC Reader
string NC_READER_CONTENT_SEPARATOR="%&§";

//plugins related
string MY_PLUGIN_MENU="npose_menu";
string MY_PLUGIN_MENU_PICK_SEAT="npose_pickseat";
string MY_PLUGIN_MENU_UNSIT="npose_unsit";
string MY_PLUGIN_MENU_CHANGE_SEAT="npose_changeseat";
string MME_PLUGIN_MENU_NAME="npose_mme";

//Button comments marker
string MARKER_COMMENT_START="/*";
string MARKER_COMMENT_END="*/";

//holds the name of the menu order notecard to read.
string CHANGE_MENU_ORDER_NC_NAME=".Change Menu Order";
//holds the name of the nPose MenuMemoryExtension configuration NC
string MME_NC_NAME=".nPose MenuMemoryExtension";


//default options settings.  Change these to suit personal preferences
float MenuDistance = 30.0;
integer OptionAutoLanguage=1; //if disabled, only the default language will be used, if enabled the script tries to determine the agent language
string OptionDefaultLanguagePrefix=DEFAULT_PREFIX; //mainly for debug purposes. Set autoLanguage=0 and defaultLanguagePrefix to a 2 letter language code to see the language of your choice
string OptionOnMenuForbiddenMessage;
integer OptionOnMenuForbiddenRemenu=1;

list Slots; //this Slots list is not complete. it only contains seated AV key + seated AV Type + seated AV Display name + seat names
integer SLOTS_SITTER_KEY=0;
integer SLOTS_SITTER_TYPE=1;
integer SLOTS_SITTER_NAME=2;
integer SLOTS_SEAT_NAME=3;
integer SLOTS_STRIDE=4;

integer SITTER_TYPE_NONE=0;
integer SITTER_TYPE_AVATAR=1;
integer SITTER_TYPE_BUDDY=2;


list MenuPaths;
list MenuButtons;
list MenuPermPath;
list MenuPermPerms;

list PluginBasePathList; //store plugins base paths
list PluginParamsList; //PluginName|PluginMenuParams|PluginActionParams

list MmePluginBasePathList;
list MmePluginWorkerNumberList;

key ScriptId;

list UdpList;
list MacroList;
//list MacroNames;
//list MacroValues;

integer UseMme; //MenuMemoryExtension
integer UseChangeMenuOrder;

integer MyWorkerNumber;

integer TotalNumberOfValidCards; //only for your info
integer TotalNumberOfStoredCards; //only for your info

/*
debug(list message){
    llOwnerSay((((llGetScriptName() + "\n##########\n#>") + llDumpList2String(message,"\n#>")) + "\n##########"));
}
*/

DoMenu(key rcpt, string path, integer page, string prompt, list additionalButtons) {
    list choices;
    integer index = llListFindList(MenuPaths, [path]);
    if(~index) {
        choices=llParseStringKeepNulls(llList2String(MenuButtons, index), ["|"], []);
    }
    //Merge the buttons generated by NCs (choices) and the buttons generated by a plugin (additionalButtons)
    integer length=llGetListLength(additionalButtons);
    for(index=0; index<length; index++) {
        integer searchIndex=llListFindList(choices, [llList2String(additionalButtons, index)]);
        if(~searchIndex) {
            choices=llDeleteSubList(choices, searchIndex, searchIndex);
        }
    }
    choices+=additionalButtons;
    
    //path is already checked, now check the button permissions
    list thisMenuPath=llParseStringKeepNulls(path , [":"], []);
    integer rcptSlotNumber=llListFindList(Slots, [rcpt]);
    if(~rcptSlotNumber) {
        rcptSlotNumber=rcptSlotNumber/SLOTS_STRIDE;
    }
    //check button permission for each button
    integer stopc = llGetListLength(choices);
    integer nc;
    for(nc=0; nc < stopc; ++nc) {
        integer indexc = llListFindList(MenuPermPath, [llDumpList2String(thisMenuPath + llList2String(choices, nc), ":")]);
        if(indexc != -1) {
            if(!isAllowed(0, rcpt, rcptSlotNumber, llList2String(MenuPermPerms, indexc))) {
                choices = llDeleteSubList(choices, nc, nc);
                --nc;
                --stopc;
            }
        }
    }
    //generate utility buttons
    list utilitybuttons;
    
    //call the dialog
    llMessageLinked(LINK_SET, DIALOG, llDumpList2String([
        (string)rcpt,
        prompt,
        (string)page,
        llDumpList2String(choices, "`"),
        llDumpList2String(utilitybuttons, "`"),
        path
    ], "|"), ScriptId);
}

string getAllowedPath(key rcpt, string path) {
    //check permission from root to this path
    //and return the last valid path
    //this also means that button permissions are inheritable
    //example:
    //SET:Test:Test{false}:BTN
    //returns "SET:Test"
    integer rcptSlotNumber=llListFindList(Slots, [rcpt]);
    if(~rcptSlotNumber) {
        rcptSlotNumber=rcptSlotNumber/SLOTS_STRIDE;
    }

    list thisMenuPath=llParseStringKeepNulls(path , [":"], []);
    list testPath;
    integer break;
    while(llGetListLength(thisMenuPath) && !break) {
        testPath+=llList2String(thisMenuPath, 0);
        thisMenuPath=llDeleteSubList(thisMenuPath, 0, 0);
        integer index=llListFindList(MenuPermPath, [llDumpList2String(testPath, ":")]);
        if(~index) {
            if(!isAllowed(0, rcpt, rcptSlotNumber, llList2String(MenuPermPerms, index))) {
                break=TRUE;
            }
        }
    } 
    if(break) {
        testPath=llDeleteSubList(testPath, -1, -1);
    }
    return llDumpList2String(testPath, ":");
}

/*
integer checkPathPermissions(key rcpt, string path) {
    //check permission for this path up to the root
    //this also means that button permissions are inheritable
    list thisMenuPath=llParseStringKeepNulls(path , [":"], []);
    integer rcptSlotNumber=llListFindList(Slots, [rcpt]);
    if(~rcptSlotNumber) {
        rcptSlotNumber=rcptSlotNumber/SLOTS_STRIDE;
    }
    do {
        integer indexc=llListFindList(MenuPermPath, [llDumpList2String(thisMenuPath, ":")]);
        if(~indexc) {
            if(!isAllowed(0, rcpt, rcptSlotNumber, llList2String(MenuPermPerms, indexc))) {
                return 0;
            }
        }
    } while (llGetListLength(thisMenuPath=llDeleteSubList(thisMenuPath, -1, -1)));
    return 1;
}
*/

integer isAllowed(integer mode, key avatarKey, integer slotNumber, string permissions) {
    // avatarKey: the key of the avatar using the menu

    // mode 0: (menu button check) 
    //    slotNumber: the slot number of the menu user (if the menu user is not in the slot list, provide a -1)

    // mode 1 (slot button check)
    //    slotNumber: the slotnumber for which the button should be created
    
    
    // Syntax of the permission string:
    // The permission string is the last part of the notecard name surrounded by {}
    // it can also be used in the change seat or unsit command
    // It contains KEYWORDS and OPERATORS.

    // OPERATORS (listed in order of their precedence)
    // ! means a logical NOT
    // & means a logical AND
    // ~ means a logical OR
    // Operators may be surrounded by spaces

    // KEYWORDS (case insensitive)
    // owner:
    //        mode 0: returns TRUE if the menu user is the object owner
    //        mode 1: returns TRUE if the object owner is sitting on the specified seat
    // group:
    //        mode 0: returns TRUE if the active group of the menu user is equal to the group of the object
    //        mode 1: returns TRUE if the active group of the user sitting on the specified seat is equal to the group of the object
    // seated:
    //        mode 0: returns TRUE if the menu user is seated
    //        mode 1: no usefull meaning
    // occupied:
    //        mode 0: no usefull meaning
    //        mode 1: returns TRUE if the given slot is in use by an Avatar
    // ownseat:
    //        mode 0: no usefull meaning
    //        mode 1: returns TRUE if the menu user sits in the specified slot
    // any integer followed by ".empty" counts as a seatNumber:
    //        mode 0: returns TRUE if the seat is not occupied with an avatar
    //        mode 1: TODO
    // any integer counts as a seatNumber:
    //        mode 0: returns TRUE if menu user sits on the seat with the number seatNumber
    //        mode 1: returns TRUE if the specified slotNumber represents the seat with the number seatNumber
    // any string that beginns with a "@":
    //       is a macro, which gets recursivly parsed
    // any other string counts as a UserDefinedPermission
    //        type list:
    //            mode 0: returns TRUE if the menu user is within the list
    //            mode 1: returns TRUE if the user sitting on the specified seat is within the list
    //        type bool:
    //            all modes: returns the value of the UserDefinedPermission

    // Examples:
    // mode 0:
    // 1~3 : is TRUE if the menu user is seated on seat number 1 or 3
    // owner~2 : is TRUE if the menu user is the object owner or if the menu user is sitting on seat number 2
    // owner&!victim : is TRUE if the menu user is the object owner, but only if he/she isn't a victim (victim is a UserDefinedPermission used by the RLV+ plugin)
    // 1~3&group: is TRUE for the user on seat 1 and also for the user on seat 3 if he/she has the same active group as the Object
    permissions=llStringTrim(permissions, STRING_TRIM);
    if(permissions=="") {
        return TRUE;
    }
    key avatarInSlot;
    if(~slotNumber) {
        avatarInSlot=llList2Key(Slots, slotNumber*SLOTS_STRIDE);
    }
    list permItemsOr=llParseString2List(llToLower(permissions), ["~"], []);
    integer indexOr=~llGetListLength(permItemsOr);
    integer result;
    while(++indexOr && !result) {
        list permItemsAnd=llParseString2List(llList2String(permItemsOr, indexOr), ["&"], []);
        integer indexAnd=~llGetListLength(permItemsAnd);
        result=TRUE;
        while(++indexAnd && result) {
            integer invert;
            string item=llStringTrim(llList2String(permItemsAnd, indexAnd), STRING_TRIM);
            if(llGetSubString(item, 0, 0)=="!") {
                invert=TRUE;
                item=llStringTrim(llDeleteSubString(item, 0, 0), STRING_TRIM);
            }
            if(item==PERMISSION_GROUP) {
                if(!mode) {
                    result=llSameGroup(avatarKey);
                }
                else {
                    result=llSameGroup(avatarInSlot);
                }
            }
            else if(item==PERMISSION_OWNER) {
                if(!mode) {
                    result=llGetOwner()==avatarKey;
                }
                else {
                    result=llGetOwner()==avatarInSlot;
                }
            }
            else if(item==PERMISSION_SEATED) {
                result=slotNumber>=0;
            }
            else if(item==PERMISSION_OCCUPIED) {
                result=llList2Integer(Slots, slotNumber*SLOTS_STRIDE + SLOTS_SITTER_TYPE)==SITTER_TYPE_AVATAR;
            }
            else if(item==PERMISSION_OWNSEAT) {
                result=avatarKey==avatarInSlot;
            }
            else if(~llSubStringIndex(item, ".empty")) {
                result=llList2Integer(Slots, ((integer)llGetSubString(item, 0, -7)-1)*SLOTS_STRIDE + SLOTS_SITTER_TYPE)!=SITTER_TYPE_AVATAR;
            }
            else if((string)((integer)item)==item){
                result=slotNumber+1==(integer)item;
            }
            else if(llGetSubString(item, 0, 0)=="@") {
                integer macroIndex=llListFindList(MacroList, [llDeleteSubString(item, 0, 0) , MACRO_TYPE]);
                if(~macroIndex) {
                    result=isAllowed(mode, avatarKey, slotNumber, llList2String(MacroList, macroIndex + 2));
                }
                else {
                    //unknown Macro: assume that it is set to ""
                    result=FALSE;
                }
            }
            else {
                //maybe a user defined permission
                integer udpIndex=llListFindList(UdpList, [item]);
                if(~udpIndex) {
                    //plugin permission
                    string pluginPermissionType=llList2String(UdpList, udpIndex+1);
                    if(pluginPermissionType==UDP_TYPE_LIST) {
                        if(!mode) {
                            result=~llSubStringIndex(llList2String(UdpList, udpIndex+2), (string)avatarKey);
                        }
                        else {
                            result=~llSubStringIndex(llList2String(UdpList, udpIndex+2), (string)avatarInSlot);
                        }
                    }
                    else if(pluginPermissionType==UDP_TYPE_BOOL) {
                        result=(integer)llList2String(UdpList, udpIndex+2);
                    }
                    else {
                        //error unknown plugin permission type
                        result=FALSE;
                    }
                }
                else {
                    //maybe the plugin has not registered itself right now. So assume a blank list or a 0 as value
                    result=FALSE;
                }
            }
            //logicalXor
            result=(invert && !result) || (!invert && result);
        }
    }
    return result;
}

BuildMenus(list cardNames) {//builds the user defined menu buttons
    integer length = llGetListLength(cardNames);
    if(!UseChangeMenuOrder) {
        length = llGetInventoryNumber(INVENTORY_NOTECARD);
    }
    integer indexNC;
    for(indexNC=0; indexNC<length; ++indexNC) {//step through the notecards
        string path = llList2String(cardNames, indexNC);
        if(!UseChangeMenuOrder) {
            path = llGetInventoryName(INVENTORY_NOTECARD, indexNC);
        }
        AddMenuButton(path, FALSE);
    }
}

AddMenuButton(string path, integer addUnconditional) {
    integer permsIndex1 = llSubStringIndex(path,"{");
    integer permsIndex2 = llSubStringIndex(path,"}");
    string menuPerms;
    if(permsIndex1>0 && permsIndex2>permsIndex1) { // found
        menuPerms = llGetSubString(path, permsIndex1+1, permsIndex2+-1);
        path = llDeleteSubString(path, permsIndex1, permsIndex2);
    }
    list pathParts = llParseStringKeepNulls(path, [":"], []);
    string prefix = llList2String(pathParts, 0);

    if(prefix==DEFAULT_PREFIX || (llStringLength(prefix)==2 && llToUpper(prefix)==prefix)) { // found
        TotalNumberOfValidCards+=!addUnconditional;
        if(menuPerms) {
            MenuPermPath += llDumpList2String(pathParts, ":");
            MenuPermPerms += menuPerms;
        }
        integer storeCard=TRUE;
        if(UseMme && !addUnconditional) {
            if(getMmeWorkerNumber(path)!=MyWorkerNumber) {
                storeCard=FALSE;
            }
        }
        if(storeCard) {
            TotalNumberOfStoredCards+=!addUnconditional;
            while(llGetListLength(pathParts)>1) {
                string last = llList2String(pathParts, -1);
                string parentPath = llDumpList2String(llDeleteSubList(pathParts, -1, -1), ":");
                integer indexParentPath = llListFindList(MenuPaths, [parentPath]);
                if(~indexParentPath) {
                    list children = llParseStringKeepNulls(llList2String(MenuButtons, indexParentPath), ["|"], []);
                    if(!~llListFindList(children, [last])) {
                        children += [last];
                        if(!UseChangeMenuOrder) {
                            children = llListSort(children, 1, 1);
                        }
                        MenuButtons = llListReplaceList(MenuButtons, [llDumpList2String(children, "|")], indexParentPath, indexParentPath);
                    }
                }
                else {
                    MenuPaths += [parentPath];
                    MenuButtons += [last];
                }
                pathParts = llDeleteSubList(pathParts, -1, -1);
            }
        }
    }
}

string getNcName(string path) {
    integer permissionIndex = llListFindList(MenuPermPath, [path]);
    if(~permissionIndex) {
        string thisPerm = llList2String(MenuPermPerms, permissionIndex);
        if(thisPerm != "") {
            path+="{"+thisPerm+"}";
        }
    }
    if(llGetInventoryType(path) == INVENTORY_NOTECARD) {
        return path;
    }
    return "";
}

//helper
string deleteNodes(string path, integer start, integer end) {
    return llDumpList2String(llDeleteSubList(llParseStringKeepNulls(path, [":"], []), start, end), ":");
}
//helper
string getNodes(string path, integer start, integer end) {
    return llDumpList2String(llList2List(llParseStringKeepNulls(path, [":"], []), start, end), ":");
}

//helper
string buildParamSet1(string path, integer page, string prompt, list additionalButtons, list pluginParams) {
    //pluginParams are: string pluginLocalPath, string pluginName, string pluginMenuParams, string pluginActionParams
    //We can't use colons in the promt, because they are used as a seperator in other messages
    //so we replace them with a UTF Symbol
    return llDumpList2String([
        path,
        page,
        llDumpList2String(llParseStringKeepNulls(prompt, [","], []), "‚"), // CAUTION: the 2nd "‚" is a UTF sign!
        llDumpList2String(additionalButtons, ",")
    ] + llList2List(pluginParams + ["", "", "", ""], 0, 3), "|");
}

list getPluginParams(string path) {
    //returns:
    //[pluginLocalPath, pluginName, pluginMenuParams, pluginActionParams]
    
    string pluginBasePath=path;
    while(pluginBasePath!="") {
        integer index=llListFindList(PluginBasePathList, [pluginBasePath]);
        if(~index) {
            return 
                [llDeleteSubString(path, 0, llStringLength(pluginBasePath))] +
                llList2List(llParseStringKeepNulls(llList2String(PluginParamsList, index), ["|"], []) + ["", "", "", ""], 0, 3)
            ;
        }
        else {
            pluginBasePath=deleteNodes(pluginBasePath, -1, -1);
        }
    }
    return [path, MY_PLUGIN_MENU, "", ""];
}

integer getMmeWorkerNumber(string path) {
    //gets the MenuMemoryExtension worker number for the provided path.
    //returns:
    //WorkerNumber
    
    while(path!="") {
        integer index=llListFindList(MmePluginBasePathList, [path]);
        if(~index) {
            return llList2Integer(MmePluginWorkerNumberList, index);
        }
        else {
            path=deleteNodes(path, -1, -1);
        }
    }
    return 0;
}


init() {
    MenuPaths = [];
    MenuButtons = [];
    MenuPermPath = [];
    MenuPermPerms = [];
    PluginBasePathList=[];
    PluginParamsList=[];
    MmePluginBasePathList=[];
    MmePluginWorkerNumberList=[];
    TotalNumberOfValidCards=0;
    TotalNumberOfStoredCards=0;

    UseMme=llGetInventoryType(MME_NC_NAME)==INVENTORY_NOTECARD;
    UseChangeMenuOrder=llGetInventoryType(CHANGE_MENU_ORDER_NC_NAME)==INVENTORY_NOTECARD;
    ScriptId=llGetInventoryKey(llGetScriptName());
    //Notice: the MenuMemoryExtension does not work (well) if you also use the ".Change Menu Order" mechanism
    //My point of view (Leona): avoid the ".Change Menu Order" and use Button Comments to sort the menu manually
    if(UseMme || UseChangeMenuOrder) {
        llSleep(1.5); //be sure that the NC reader script finished resetting
        if(UseMme) {
            llMessageLinked(LINK_SET, NC_READER_REQUEST, MME_NC_NAME, ScriptId);
        }
        if(UseChangeMenuOrder) {
            llMessageLinked(LINK_SET, NC_READER_REQUEST, CHANGE_MENU_ORDER_NC_NAME, ScriptId);
        }
    }
    else {
        BuildMenus([]);
    }
}

default{
    state_entry() {
        init();
    }
    
    touch_start(integer total_number) {
        key toucherKey = llDetectedKey(0);
        vector vDelta = llDetectedPos(0) - llGetPos();
        if(toucherKey == llGetOwner() || llVecMag(vDelta) < MenuDistance) {
            llMessageLinked(LINK_SET, DOMENU, llDumpList2String(["", 0, ""], ","), toucherKey);
        }
    }
    
    link_message(integer sender, integer num, string str, key id) {
        if(
            (num==DIALOG_RESPONSE && id == ScriptId ) ||
            num==DOMENU ||
            num==PREPARE_MENU_STEP1 ||
            num==PREPARE_MENU_STEP2 ||
            num==PLUGIN_MENU_DONE ||
            num==MENU_SHOW
        ) {
            string path;
            integer page;
            string prompt;
            string additionalButtons;
            list pluginParams;
            string selection;
            key toucherId;

            //the following block is to sort the paramters from the different message (to be backward compatible)
            //a better way would be to harmonize these parameters
            if(num==DOMENU) {
                toucherId=id;
                list params = llParseStringKeepNulls(str, [","], []);  //parse the message
                //str: path[, page[, prompt]]
                path=llList2String(params, 0);
                if(path=="") {
                    path=OptionDefaultLanguagePrefix;
                    if(OptionAutoLanguage) {
                        string agentLanguage=llToUpper(llGetAgentLanguage(toucherId));
                        if(llStringLength(agentLanguage)>2) {
                            if(llGetSubString(agentLanguage, 2, 2)=="-") {
                                agentLanguage=llGetSubString(agentLanguage, 0, 1);
                            }
                        }
                        if(~llListFindList(MenuPaths, [agentLanguage])) {
                            path=agentLanguage;
                        }
                    }
                }
                page=(integer)llList2String(params, 1);
                prompt=llList2String(params, 2);
            }
            else if(num == DIALOG_RESPONSE) {
                list params = llParseStringKeepNulls(str, ["|"], []);  //parse the message
                page = (integer)llList2String(params, 0);  //get the page number
                selection = llList2String(params, 1);  //get the button that was pressed from str
                toucherId = llList2Key(params, 2);
                path = llList2String(params, 3); //get the path from params list
                if(path!="" && selection!="") {
                    path+=":";
                }
                path+=selection;
            }
            else {
                list params=llParseStringKeepNulls(str, ["|"], []);
                path=llList2String(params, 0);
                page=(integer)llList2String(params, 1);
                prompt=llList2String(params, 2);
                additionalButtons=llList2String(params, 3);
                pluginParams=llList2List(params, 4, 7);
                toucherId=id;
            }
            //block end

            if(num == DIALOG_RESPONSE || num==DOMENU) {
                integer skipNcExecution;
                //allowed path detection
                string allowedPath=getAllowedPath(toucherId, path);
                if(allowedPath!=path) {
                    if(OptionOnMenuForbiddenMessage) {
                        llRegionSayTo(toucherId, 0, OptionOnMenuForbiddenMessage);
                    }
                    if(OptionOnMenuForbiddenRemenu) {
                        path=allowedPath;
                        page=0;
                        num=PREPARE_MENU_STEP2;
                    }
                    skipNcExecution=TRUE;
                }
                //BackButton
                if(getNodes(path, -1, -1)==BACKBTN) {
                    path=deleteNodes(path, -2, -1);
                    page=0;
                    num=PREPARE_MENU_STEP2;
                    skipNcExecution=TRUE;
                }
                if(!skipNcExecution) {
                    string ncName=getNcName(path);
                    if(ncName) {
                        //there is a NC that should be executed
                        string paramSet1=buildParamSet1(path, page, prompt, [], []);
                        llMessageLinked(LINK_SET, DOPOSE, ncName + NC_READER_CONTENT_SEPARATOR + paramSet1, toucherId);
                    }
                    else {
                        //no NC to be executed, initiate the remenu process without piping the messages trough the core
                        num=PREPARE_MENU_STEP1;
                    }
                }
            }
        
            if(num==PREPARE_MENU_STEP1) {
                pluginParams=getPluginParams(path);
                if(llList2String(pluginParams, 1)!=MY_PLUGIN_MENU) {
                    //handled by a different plugin
                    string paramSet1=buildParamSet1(path, page, prompt, [additionalButtons], pluginParams);
                    llMessageLinked(LINK_SET, PLUGIN_ACTION, paramSet1, toucherId);
                }
                else {
                    //handled by us
                    if(~llListFindList(MenuPaths, [path])) {
                        //this is a node
                        page=0;
                    }
                    else {
                        path=deleteNodes(path, -1, -1);
                    }
                    num=PREPARE_MENU_STEP2;
                }
            }
            
            if(num==PREPARE_MENU_STEP2) {
                pluginParams=getPluginParams(path);
                if(llList2String(pluginParams, 1)!=MY_PLUGIN_MENU) {
                    //handled by a different plugin
                    string paramSet1=buildParamSet1(path, page, prompt, [additionalButtons], pluginParams);
                    llMessageLinked(LINK_SET, PLUGIN_MENU, paramSet1, toucherId);
                }
                else {
                    //handled by us
                    string paramSet1=buildParamSet1(path, page, prompt, [additionalButtons], []);
                    llMessageLinked(LINK_SET, PREPARE_MENU_STEP3, getNcName(path) + NC_READER_CONTENT_SEPARATOR + paramSet1, toucherId);
                }
            }
            if(num==PLUGIN_MENU_DONE) {
                string paramSet1=buildParamSet1(path, page, prompt, [additionalButtons], []);
                llMessageLinked(LINK_SET, PREPARE_MENU_STEP3, getNcName(path) + NC_READER_CONTENT_SEPARATOR + paramSet1, toucherId);
            }
            if(num == MENU_SHOW) {
                DoMenu(toucherId, path, page, prompt, llParseString2List(additionalButtons, [","], []));
            }
        }
        else if(num==PLUGIN_MENU_REGISTER) {
            list params=llParseStringKeepNulls(str, ["|"], []);
            string pluginBasePath=llList2String(params, 0);
            string pluginParams=llDumpList2String([llToLower(llList2String(params, 1)), llList2String(params, 2), llList2String(params, 3)], "|");
            integer index=llListFindList(PluginBasePathList, [pluginBasePath]);
            if(~index) {
                PluginBasePathList=llListReplaceList(PluginBasePathList, [pluginBasePath], index, index);
                PluginParamsList=llListReplaceList(PluginParamsList, [pluginParams], index, index);
            }
            else {
                PluginBasePathList+=pluginBasePath;
                PluginParamsList+=pluginParams;
            }
        }
        else if(num==PLUGIN_ACTION || num==PLUGIN_MENU) {
            //the menu script itself contains a few menu plugins.
            //the former admin menu is not part of it. We could simply use NCs for it.
            list params=llParseStringKeepNulls(str, ["|"], []);
            string path=llList2String(params, 0);
            integer page=(integer)llList2String(params, 1);
            string prompt=llList2String(params, 2);
            string additionalButtons=llList2String(params, 3);
            string pluginLocalPath=llList2String(params, 4);
            string pluginName=llList2String(params, 5);
            string pluginMenuParams=llList2String(params, 6);
            string pluginActionParams=llList2String(params, 7);

            if(pluginName==MY_PLUGIN_MENU_CHANGE_SEAT || pluginName==MY_PLUGIN_MENU_UNSIT || pluginName==MY_PLUGIN_MENU_PICK_SEAT) {
                //this is the pick seat menu. It should stay inside this script, because it uses the isAllowed function and the Slots list.
                //If LL would allow us to use more script memory this should go to the core
                if(num==PLUGIN_ACTION) {
                    // 1) Do the action if needed
                    // 2) correct the path if needed
                    // 3) finish with a PLUGIN_ACTION_DONE call
                    integer remenu=TRUE;
                    if(pluginLocalPath!="") {
                        //a new seat is selected
                        //the button comment contains the slot number
                        integer index=llSubStringIndex(pluginLocalPath, MARKER_COMMENT_END);
                        if(~index) {
                            integer slotNumber=(integer)llGetSubString(pluginLocalPath, 2, index);
                            key avatarInSlot=llList2Key(Slots, slotNumber*SLOTS_STRIDE);
                            if(pluginName==MY_PLUGIN_MENU_CHANGE_SEAT || llToLower(pluginActionParams)=="changeseat") {
                                llMessageLinked(LINK_SET, DO, "SWAP|" + llList2CSV([slotNumber+1, "%AVSEAT%"]), id);
                            }
                            else if(pluginName==MY_PLUGIN_MENU_UNSIT || llToLower(pluginActionParams)=="unsit") {
                                llMessageLinked(LINK_SET, DO, "UNSIT|" + (string)avatarInSlot, id);
                                if(avatarInSlot==id) {
                                    //don't remenu if someone unsits oneself
                                    remenu=FALSE;
                                }
                            }
                            else if((integer)pluginActionParams) {
                                llMessageLinked(LINK_SET, (integer)pluginActionParams, llDumpList2String([slotNumber+1, avatarInSlot], "|"), id);
                            }
                        }
                        //set path to plugin root path
                        path=llGetSubString(path, 0, -llStringLength(pluginLocalPath)-2);
                    }
                    if(remenu) {
                        llMessageLinked(LINK_SET, PLUGIN_ACTION_DONE, buildParamSet1(path, page, prompt, [additionalButtons], []), id);
                    }
                }
                else if(num==PLUGIN_MENU) {
                    // 1) set a prompt if needed
                    // 2) generate your buttons if needed
                    // 3) finish with a PLUGIN_MENU_DONE call
                    //pluginMenuParams: permissionString,avatar or seatnumber to highlight, prompt

                    list pluginMenuParamsList=llParseStringKeepNulls(pluginMenuParams, [","], []);
                    string permissionString=llList2String(pluginMenuParamsList, 0);
                    string highlight=llList2String(pluginMenuParamsList, 1);

                    integer highlightSlot=-1;
                    key highlightAvatar=id;

                    if(pluginName==MY_PLUGIN_MENU_PICK_SEAT) {
                        highlightSlot=((string)((integer)highlight)==highlight)*(integer)highlight - 1;
                        highlightAvatar=(key)highlight;
                        if(llList2String(pluginMenuParamsList, 2)) {
                            prompt=llList2String(pluginMenuParamsList, 2);
                        }
                    }
                    else if(pluginName==MY_PLUGIN_MENU_CHANGE_SEAT) {
                        prompt="Where will you sit?";
                    }
                    else if(pluginName==MY_PLUGIN_MENU_UNSIT) {
                        prompt="Pick an avatar to unsit.";
                    }
                    //build and show the menu
                    //generate the buttons
                    //A button will be
                    //1) if someone/something sits on the seat: the sitter name
                    //2) else: the seat name
                    //We can highlight one avatar or one slotnumber by surrounding a "?". In the standart unsit/changeSeat menu this will be the menu user
                    //We use the "button comment" to store the slotnumber to make it easier to parse the response
                    integer length=llGetListLength(Slots);
                    list buttons;
                    integer index;
                    for(index=0; index<length; index+=SLOTS_STRIDE) {
                        if(isAllowed(1, id, index/SLOTS_STRIDE, permissionString)) {
                            string currentButtonName;
                            integer sitterType=llList2Integer(Slots, index + SLOTS_SITTER_TYPE);
                            key sitterKey=llList2Key(Slots, index + SLOTS_SITTER_KEY);
                            if(sitterType!=SITTER_TYPE_NONE && llList2String(Slots, index + SLOTS_SITTER_NAME)!="") {
                                currentButtonName+=llList2String(Slots, index + SLOTS_SITTER_NAME);
                            }
                            else {
                                currentButtonName+=llList2String(Slots, index + SLOTS_SEAT_NAME);
                            }
                            //highlight
                            if(sitterKey==highlightAvatar || index/SLOTS_STRIDE==highlightSlot) {
                                currentButtonName="?" + currentButtonName + "?";
                            }

                            currentButtonName=MARKER_COMMENT_START + (string)(index/SLOTS_STRIDE) + MARKER_COMMENT_END + currentButtonName;
                            buttons+=[currentButtonName];
                        }
                    }
                    llMessageLinked(LINK_SET, PLUGIN_MENU_DONE, buildParamSet1(path, page, prompt, buttons, []), id);
                }
            }
        }
//begin handle link message inputs
        else if(num == OPTIONS) {
            //save new option(s) from LINKMSG
            list optionsToSet;
            optionsToSet = llParseStringKeepNulls(str, ["|"], []);
            integer length = llGetListLength(optionsToSet);
            integer index;
            for(index=0; index<length; ++index) {
                list optionsItems = llParseString2List(llList2String(optionsToSet, index), ["="], []);
                string optionItem = llToLower(llStringTrim(llList2String(optionsItems, 0), STRING_TRIM));
                string optionString = llList2String(optionsItems, 1);
                string optionSetting = llToLower(llStringTrim(optionString, STRING_TRIM));
                integer optionSettingFlag = optionSetting=="on" || (integer)optionSetting;

                if(optionItem == "menudist") {MenuDistance = (float)optionSetting;}
                else if(optionItem == "autolanguage") {OptionAutoLanguage = optionSettingFlag;}
                else if(optionItem == "defaultlanguageprefix") {OptionDefaultLanguagePrefix = llToUpper(optionSetting);}
                else if(optionItem == "onmenuforbiddenmessage") {OptionOnMenuForbiddenMessage = optionString;}
                else if(optionItem == "onmenuforbiddenremenu") {OptionOnMenuForbiddenRemenu = optionSettingFlag;}
            }
        }
        else if(num == UPDATE_UDP) {
            UdpList=llParseStringKeepNulls(str, ["|"], []);
        }
        else if(num == UPDATE_MACRO) {
            MacroList=llParseStringKeepNulls(str, ["|"], []);
        }
        else if(num == NC_READER_RESPONSE) {
            if(id==ScriptId) {
                if(!llSubStringIndex(str, CHANGE_MENU_ORDER_NC_NAME)) {
                    //Change Menu Order
                    BuildMenus(llList2List(llParseStringKeepNulls(str, [NC_READER_CONTENT_SEPARATOR], []), 3, -1));
                    str = "";
                }
                else {
                    //parse mme
                    list mmeConfig=llList2List(llParseStringKeepNulls(str, [NC_READER_CONTENT_SEPARATOR], []), 3, -1);
                    integer currentMmeConfigWorkerNumber;
                    while(llGetListLength(mmeConfig)) {
                        string line=llList2String(mmeConfig, 0);
                        mmeConfig=llDeleteSubList(mmeConfig, 0, 0);
                        string trimmedLine=llStringTrim(line, STRING_TRIM);
                        if(llGetSubString(trimmedLine, 0, 0)=="[" && llGetSubString(trimmedLine, -1, -1)=="]") {
                            //this is a line with the worker number. Example: [1]
                            currentMmeConfigWorkerNumber=(integer)llDeleteSubString(llDeleteSubString(trimmedLine, 0, 0), -1, -1);
                        }
                        else {
                            //this is a line with a path. Example: SET:Female
                            MmePluginBasePathList+=[line];
                            MmePluginWorkerNumberList+=[currentMmeConfigWorkerNumber];
                            string pluginName=MY_PLUGIN_MENU;
                            if(currentMmeConfigWorkerNumber) {
                                pluginName=MME_PLUGIN_MENU_NAME + (string)currentMmeConfigWorkerNumber;
                            }
                            PluginBasePathList+=[line];
                            PluginParamsList+=[pluginName];
                        }
                    }
                    //add buttons
                    integer index;
                    integer length=llGetListLength(MmePluginBasePathList);
                    for(index=0; index<length; index++) {
                        string path=llList2String(MmePluginBasePathList, index);
                        if(getMmeWorkerNumber(deleteNodes(path, -1, -1))==MyWorkerNumber) {
                            AddMenuButton(path, TRUE);
                        }
                    }
                    if(!UseChangeMenuOrder) {
                        BuildMenus([]);
                    }
                }
            }
        }
        else if(num==SEAT_UPDATE) {
            Slots = [];
            list slotsList=llParseStringKeepNulls(str, ["^"], []);
            str="";
            integer slotsStride=(integer)llList2String(slotsList, 0);
            integer preambleLength=(integer)llList2String(slotsList, 1);
            slotsList=llDeleteSubList(slotsList, 0, preambleLength-1);

            while(slotsList) {
                Slots += [
                    (key)llList2String(slotsList, 8), // sitter key
                    (integer)llList2String(slotsList, 9), // sitter type
                    llList2String(slotsList, 10), // sitter name
                    llList2String(slotsList, 0) // seat name
                ];
                slotsList=llDeleteSubList(slotsList, 0, slotsStride-1);
            }
        }
        else if(num == MEMORY_USAGE) {//dump memory stats to local
            llSay(0,
                "Memory used by " + llGetScriptName() + ": " + (string)llGetUsedMemory() + " of " + (string)llGetMemoryLimit()
                + ", leaving " + (string)llGetFreeMemory() + " memory free. \n"
                + "Storing " + (string)TotalNumberOfStoredCards + " out of " + (string)TotalNumberOfValidCards + " valid Notecards."
            );
        }
//end handle link message inputs
    }

    changed(integer change) {
        if(change & CHANGED_INVENTORY) {
            init();
        }
    }

    on_rez(integer params) {
        llResetScript();
    }
}
